# 数据劫持

Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

# 双向绑定的三种思路

-   发布者-订阅者模式（backbone.js）

-   脏值检查（angular.js） 
    -   通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测。

-   数据劫持（vue.js）
    -  采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

# vue双向绑定思路整理

1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
4、mvvm入口函数，整合以上三者

![图片描述](mvvm.png)

1.  入口文件实现
    -  mvvm实例传递一个对象，对象有一个el和一个对象data。
    -  为了实现vm.title获得属性，而不是vm.data.title，使用代理方法。
    -  调用observer和compile
2.  observer(观察者)实现
    -  为参数对象及子对象设置get和set
    -  订阅者数组Dep实现，添加订阅者和通知更新方法
3.  watcher实现
    -  在自身实例化的过程中，往订阅器(dep) 中添加自己
    -  当数据发生变动，dep.notify() 通知时，其能调用自身的 update 函数，并触发 compile 绑定的回调函数实现视图更新
4.  compile实现
    -  首先遍历解析的过程有多次操作 dom 节点，为提高性能和效率，会先将跟节点 el 转换成 fragment(文档碎片) 进行解析编译，解析完成，再将 fragment 添加回原来的真实 dom 节点中
    -   fragment 编译解析的过程中对 {{}} 文本元素、v-on:click 事件指令、v-model 指令三种类型进行了相应的处理   

# 发布订阅模式详解

一个订阅者，一个发布者，一个订阅者容器

将要执行的事件添加到容器，当触发条件由发布者通知订阅者去执行事件

